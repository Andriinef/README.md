# OOP

## Какие принципы ООП поддерживает Python?

Принципы объектно-ориентированного программирования (ООП) в Python включают:

1. **`Инкапсуляция`** (Encapsulation): Это принцип, согласно которому класс должен скрывать внутренние детали реализации от других объектов. Это достигается путем использования атрибутов и методов класса, которые могут быть доступны только изнутри класса.

2. **`Наследование`** (Inheritance): Это принцип, согласно которому класс может наследовать свойства и методы другого класса. Класс, который наследует свойства и методы, называется подклассом, а класс, который передает свойства и методы, называется суперклассом.

3. **`Полиморфизм`** (Polymorphism): Это принцип, согласно которому различные объекты могут иметь одинаковые методы, но эти методы будут работать по-разному в зависимости от объекта, который их вызывает.

4. **`Абстракция`** (Abstraction): Это принцип, согласно которому класс должен скрывать детали реализации от других объектов и предоставлять только необходимые интерфейсы для работы с объектом. Абстракция достигается путем определения абстрактных классов и интерфейсов.

5. **`Композиция`** (Composition): Это принцип, согласно которому объект может быть создан из других объектов, которые представляют его составные части. Композиция позволяет создавать объекты с более сложным поведением и функциональностью.

6. **`SOLID`**: Это совокупность принципов, которые применяются в ООП и позволяют создавать гибкие, расширяемые и легко поддерживаемые программы. SOLID состоит из следующих принципов: Single Responsibility Principle, Open/Closed Principle, Liskov Substitution Principle, Interface Segregation Principle и Dependency Inversion Principle. (Принцип **единой ответственности**, принцип **открытости/закрытости**, принцип **подстановки Лискова**, принцип **разделения интерфейсов** и принцип **инверсии зависимостей**.)

## Что такое наследование в Python?

**`Наследование`** - это один из ключевых механизмов объектно-ориентированного программирования, который позволяет создавать новые классы на основе уже существующих классов.

В Python наследование реализуется путем создания нового класса, который наследует атрибуты и методы существующего класса, называемого "родительским" или "супер" классом. Новый класс, который наследует свойства родительского класса, называется "подклассом" или "наследником".

Для того, чтобы создать подкласс, необходимо указать родительский класс в качестве аргумента при объявлении нового класса. В подклассе можно использовать все атрибуты и методы родительского класса, а также определять свои собственные атрибуты и методы.

Пример создания подкласса, наследующего свойства родительского класса:

```python
class Animal:
    def __init__(self, name):
        self.name = name

    def speak(self):
        raise NotImplementedError("Subclass must implement abstract method")

class Dog(Animal):
    def speak(self):
        return "Woof"
```

В этом примере класс Dog является подклассом класса Animal. Он наследует атрибут name и метод speak от родительского класса, но также определяет свой собственный метод speak, который переопределяет метод speak родительского класса.

## MRO ()

MRO означает порядок разрешения методов, то есть порядок, в котором Python ищет методы для выполнения в иерархии классов. MRO определяется алгоритмом линеаризации C3, который создает уникальный и непротиворечивый порядок классов с множественным наследованием.

В Python вы можете просмотреть MRO класса, используя метод mro(). Например, рассмотрим следующую иерархию классов:

```python
class A:
    pass

class B(A):
    pass

class C(A):
    pass

class D(B, C):
    pass
```

Чтобы просмотреть MRO класса D, вы можете вызвать для него метод mro():

```python
>>> D.mro()
[<class '__main__.D'>, <class '__main__.B'>, <class '__main__.C'>, <class '__main__.A'>, <class 'object'>]
```

MRO показывает, что когда вы вызываете метод для экземпляра D, Python сначала ищет метод в D, затем в B, затем в C, затем в A и, наконец, в объекте. Такой порядок гарантирует, что методы выполняются согласованным и предсказуемым образом в сценариях множественного наследования.

## Что такое полиморфизм в Python

**`Полиморфизм`** - это свойство объектно-ориентированного программирования, которое позволяет объектам разных классов иметь одинаковые методы и свойства, но реализованные каждым классом по-разному. В Python полиморфизм реализуется за счет использования методов, которые можно переопределить в наследуемых классах, а также за счет использования механизма динамической типизации.

В Python полиморфизм может быть достигнут благодаря концепции "duck typing" - "если выглядит как утка, плавает как утка и крякает как утка, то это, вероятно, и есть утка". То есть, в Python объекты не проверяются на соответствие определенному типу данных, вместо этого методы и свойства вызываются на объектах, и если они существуют и могут быть вызваны, то это считается достаточным.

Концепция полиморфизма в Python может быть применена в различных сферах программирования. Например, рассмотрим пример полиморфизма на примере классов "Figure", "Rectangle" и "Круг":

```python
from dataclasses import dataclass


@dataclass
class Figure:
    color: str

    def square(self, *args):
        pass


@dataclass
class Rectangle(Figure):
    color: str
    length: int
    width: int

    def square(self):
        return self.length * self.width


@dataclass
class Circle(Figure):
    color: str
    circle: int

    def square(self):
        return 3.14 * self.circle ** 2


figures = [Rectangle("red", 5, 3), Circle("blue", 4)]


for figure in figures:
    print(f"Square {type(figure).__name__}: {figure.square()}")

```

В этом примере классы "Rectangle" и "Круг" являются наследниками класса "Figure" и переопределяют его метод "square()". Создаем список объектов обоих классов и проходимся по ним циклом, вызывая метод "square()" для каждого объекта.

Результат выполнения программы будет следующим:

```code
square Rectangle: 15
square Circle: 50.24
```

В данном примере мы используем полиморфизм для того, чтобы вызывать один и тот же метод "square()" для объектов разных классов, но при этом получать разный результат в зависимости от типа объекта. Это позволяет использовать один и тот же код для работы с различными типами данных и объектами, делая программу более гибкой и удобной для разработки.

## Что такое абстракции в Python

Пример **`абстракции`** в объектно-ориентированном программировании с использованием Python:

```python
from abc import ABC, abstractmethod

class Shape(ABC):
    @abstractmethod
    def area(self):
        pass

class Rectangle(Shape):
    def __init__(self, width, height):
        self.width = width
        self.height = height

    def area(self):
        return self.width * self.height

class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius

    def area(self):
        return 3.14 * self.radius * self.radius

# Usage
rectangle = Rectangle(10, 5)
print(rectangle.area())

circle = Circle(5)
print(circle.area())
```

В этом примере у нас есть абстрактный класс Shape, который определяет область абстрактного метода. Этот метод не реализован в абстрактном классе, вместо этого он оставлен для реализации в конкретных классах. Это обеспечивает соблюдение концепции абстракции, поскольку абстрактный класс не связан с деталями реализации, а только с интерфейсом.

Затем у нас есть два конкретных класса, Rectangle и Circle, которые наследуются от класса Shape и реализуют свои собственные версии метода площади. Эти классы предоставляют свои собственные уникальные реализации области, но они оба используют одно и то же имя функции, что делает их взаимозаменяемыми.

Наконец, мы можем создать экземпляры Rectangle и Circle и вызвать для них метод области. Поскольку оба класса реализуют метод области, мы можем рассматривать их как экземпляры Shape и вызывать для них область взаимозаменяемо. Это сила абстракции, поскольку она позволяет нам писать гибкий код, который может работать с разными реализациями одного и того же интерфейса.

## Что такое инсапсуляция в Python

**`Инкапсуляция`** в объектно-ориентированном программировании (ООП) - это механизм, который позволяет скрыть внутреннее состояние объекта от внешнего мира и обеспечить доступ к нему только через определенные методы и свойства объекта.

В Python есть два основных метода инкапсуляции:

1. Метод защиты (protected) с использованием одного подчеркивания перед именем атрибута или метода. Например: `_protected_attribute` или `_protected_method()`.

2. Метод приватности (private) с использованием двух подчеркиваний перед именем атрибута или метода. Например: `__private_attribute` или `__private_method()`.

Например, рассмотрим класс Person с закрытым атрибутом __age:

```python
class Person:
    def __init__(self, name, sex, age):
        self.name = name    # public
        self._sex = sex     # protected
        self.__age = age    # private

    def get_age(self):
        return self.__age

    def set_age(self, age):
        if age < 0:
            print("Age cannot be negative.")
        else:
            self.__age = age
```

В этом примере атрибут `__age` является закрытым, и к нему нельзя получить доступ извне класса без использования методов `get_age()` и `set_age()`. Метод `get_age()` позволяет получить значение `__age`, а метод `set_age()` - установить новое значение __age, но при этом проводится проверка на отрицательное значение.

Таким образом, инкапсуляция позволяет скрыть детали реализации и защитить данные объекта от изменений извне, обеспечивая контроль над доступом к ним.

Конкретный пример использования инкапсуляции в Python может выглядеть так:

```python
class BankAccount:
    def __init__(self, account_number, balance):
        self.__account_number = account_number  # закрытый атрибут
        self.__balance = balance                # закрытый атрибут

    def get_account_number(self):
        return self.__account_number

    def get_balance(self):
        return self.__balance

    def deposit(self, amount):
        if amount > 0:
            self.__balance += amount
            print(f"Deposit successful. New balance: {self.__balance}")
        else:
            print("Invalid deposit amount.")

    def withdraw(self, amount):
        if amount > 0 and amount <= self.__balance:
            self.__balance -= amount
            print(f"Withdrawal successful. New balance: {self.__balance}")
        else:
            print("Invalid withdrawal amount.")

# создаем экземпляр класса BankAccount
my_account = BankAccount("123456", 1000)

# попытка получить доступ к закрытым атрибутам
print(my_account.__account_number)  # ошибка!
print(my_account.__balance)         # ошибка!

# получаем доступ к закрытым атрибутам через методы класса
print(my_account.get_account_number())  # "123456"
print(my_account.get_balance())         # 1000

# попытка изменить закрытый атрибут напрямую
my_account.__balance = 5000   # не изменяет атрибут, а создает новый открытый атрибут!
print(my_account.get_balance())  # 1000

# изменяем закрытый атрибут через метод класса
my_account.deposit(500)
my_account.withdraw(200)
print(my_account.get_balance())  # 1300
```

В этом примере класс BankAccount представляет банковский счет, который имеет закрытые атрибуты `__account_number` и `__balance`. Для получения доступа к этим атрибутам извне класса определены методы get_account_number() и get_balance(). Также класс имеет методы deposit() и withdraw(), которые изменяют значение атрибута `__balance`, но при этом проводят проверки на допустимость операции.

При создании экземпляра класса мы не можем получить доступ к закрытым атрибутам напрямую, но можем получить доступ через методы класса. Если мы попытаемся изменить закрытый атрибут напрямую, то это не изменит его значение, а создаст новый открытый атрибут с тем же именем. Вместо этого мы должны использовать методы класса, чтобы изменить значение закрытого атрибута.

## Как создать класс, объект класса в Python?

**`Класс в Python`** - это шаблон, который определяет атрибуты и методы объекта. Он является основой объектно-ориентированного программирования в Python.

Класс можно создать в Python следующим образом:

```python
class MyClass:
    def __init__(self, attribute1, attribute2):
        self.attribute1 = attribute1
        self.attribute2 = attribute2

    def method1(self):
        return self.attribute1

    def method2(self):
        return self.attribute2
```

Далее мы можем создать объект этого класса и использовать его **`методы`**:

```python
my_object = MyClass("hello", 42)
my_object.method1()
my_object.method2()
```

Также мы можем обращаться к **`атрибутам`** объекта:

```python
print(my_object.attribute1)
print(my_object.attribute2)
```

## Какие способы доступа к атрибутам класса в Python?

В Python существует несколько способов доступа к атрибутам класса:

Обращение к атрибуту через имя класса:

```python
class MyClass:
    attr = 'value'

print(MyClass.attr) # 'value'
```

Обращение к атрибуту через экземпляр класса:

```python
class MyClass:
    attr = 'value'

obj = MyClass()
print(obj.attr) # 'value'
```

Использование методов доступа (геттеров и сеттеров):

```python
class MyClass:
    def __init__(self):
        self._attr = 'value'

    def get_attr(self):
        return self._attr

    def set_attr(self, new_value):
        self._attr = new_value

obj = MyClass()
print(obj.get_attr()) # 'value'
obj.set_attr('new_value')
print(obj.get_attr()) # 'new_value'
```

Использование декораторов @property и @attribute_name.setter:

```python
class MyClass:
    def __init__(self):
        self._attr = 'value'

    @property
    def attr(self):
        return self._attr

    @attr.setter
    def attr(self, new_value):
        self._attr = new_value

obj = MyClass()
print(obj.attr) # 'value'
obj.attr = 'new_value'
print(obj.attr) # 'new_value'
```

## Что такое конструктор класса? Как создать конструктор класса в Python?

**Конструктор класса** - это метод, который автоматически вызывается при создании объекта класса. Его основная задача - инициализировать начальные значения атрибутов объекта.

Чтобы создать конструктор класса в Python, необходимо создать метод `__init__()` внутри класса. Вот пример:

```python
class MyClass:
   def __init__(self, arg1, arg2):
      self.arg1 = arg1
      self.arg2 = arg2
```

В этом примере мы создали класс MyClass с конструктором, который инициализирует атрибуты arg1 и arg2 при создании нового объекта класса.

Теперь, при создании экземпляра класса, мы можем передать значения для arg1 и arg2:

```python
my_object = MyClass("значение1", "значение2")
```

В результате получим объект my_object, у которого значения атрибутов arg1 и arg2 будут равны "значение1" и "значение2".

## Что такое деструктор класса? Как создать деструктор класса в Python?

**`Деструктор класса`** - это метод класса, который автоматически вызывается при удалении экземпляра класса. Деструктор используется для освобождения ресурсов, выделенных объекту при создании, таких как память или файлы.

В Python деструктор класса создается с помощью метода `__del__()`. Синтаксис для создания деструктора следующий:

```python
class MyClass:
    def __init__(self):
        # конструктор

    def __del__(self):
        # деструктор
```

В деструкторе можно выполнять любые операции, необходимые для корректного завершения работы объекта. Заметьте, что деструктор может не вызываться во время работы программы, если объект не будет удален, например, если на него есть ссылки в других объектах.

Пример:

```python
class MyFile:
    def __init__(self, filename):
        self.filename = filename
        self.file = open(filename, 'w')

    def write(self, data):
        self.file.write(data)

    def __del__(self):
        self.file.close()
        print(f"File {self.filename} has been closed.")

file = MyFile("test.txt")
file.write("Hello, world!")
# объект file будет удален после завершения программы
```

В этом примере при создании экземпляра класса MyFile открывается файл для записи. В деструкторе класса файл закрывается и выводится сообщение о его закрытии.

## Что такое интерфейс класса? Как создать интерфейс класса в Python?

**`Интерфейс класса`** в Python - это набор методов и атрибутов, которые должны быть определены в любом классе, который реализует этот интерфейс. В Python интерфейс класса обычно используется для определения общих методов для нескольких классов, которые могут использоваться одним и тем же клиентским кодом без зависимости от реализации классов.

Чтобы создать интерфейс класса в Python, можно использовать абстрактные классы. Абстрактный класс - это класс, который не может быть инстанцирован напрямую, а может использоваться только в качестве базового класса для других классов (подклассов). В Python для создания абстрактного класса необходимо использовать модуль abc и декоратор @abstractmethod, который позволяет определить методы, которые должны быть реализованы в подклассах.

Пример создания интерфейса класса:

```python
from abc import ABC, abstractmethod

class Shape(ABC):
    def __init__(self, length, width):
        self.length = length
        self.width = width

    @abstractmethod
    def area(self):
        pass

    @abstractmethod
    def perimeter(self):
        pass

class Rectangle(Shape):

    def area(self):
        return self.length * self.width

    def perimeter(self):
        return 2 * (self.length + self.width)

rect = Rectangle(5, 10)
print(rect.area()) # выводит 50
print(rect.perimeter()) # выводит 30
```

В этом примере мы создаем интерфейс класса Shape, определяя абстрактные методы area() и perimeter(). Затем мы создаем класс Rectangle, наследуемый от Shape, и добавляем реализации методов area() и perimeter(). Теперь мы можем создавать экземпляры класса Rectangle и использовать их методы area() и perimeter() без необходимости знать детали реализации класса.

## Что такое множественное наследование? Как создать множественное наследование в Python?

**`Множественное наследование`** - это возможность для класса наследовать свойства и методы одновременно от нескольких родительских классов. В Python множественное наследование достигается путем указания нескольких базовых классов в объявлении подкласса.

```python
# Создание базовых классов
class Animal:
    def __init__(self, name):
        self.name = name

    def speak(self):
        return "Unknown sound"

class Mammal:
    def __init__(self, num_legs):
        self.num_legs = num_legs

    def walk(self):
        return (f"Walking on {self.num_legs} legs")

class Herbivore:
    def __init__(self, diet):
        self.diet = diet

    def eat(self):
        return (f"Eating {self.diet} plants")

# Создание подкласса, наследующего свойства и методы базовых классов
class Elephant(Animal, Mammal, Herbivore):
    def __init__(self, name, num_legs, diet):
        Animal.__init__(self, name)
        Mammal.__init__(self, num_legs)
        Herbivore.__init__(self, diet)

    def speak(self):
        return "Brrrrrrrrrr!"

# Использование объекта подкласса
elephant = Elephant("Dumbo", 4, "herbivorous")
print(elephant.name)  # Dumbo
print(elephant.walk())  # Walking on 4 legs
print(elephant.eat())  # Eating herbivorous plants
print(elephant.speak())  # Brrrrrrrrrr!
```

## Что такое класс-обертка? Как создать класс-обертку в Python?

**`Класс-обертка`** (wrapper class) - это класс, который оборачивает другой объект и предоставляет ему дополнительный функционал. Он применяется, когда необходимо расширить функциональность существующего класса без изменения его исходного кода.

В Python класс-обертку можно создать следующим образом:

1. Определить новый класс, который наследуется от класса, который нужно обернуть.

2. В конструкторе класса обертки принять экземпляр класса, который нужно обернуть, и сохранить его в классе обертке.

3. Реализовать дополнительную функциональность в методах класса обертки, используя методы и свойства обернутого объекта при необходимости.

Следующий пример демонстрирует создание класс-обертки для списка, который будет отслеживать количество добавленных и удаленных элементов:

```python
class ListWrapper:
    def __init__(self, lst):
        self.lst = lst
        self.num_added = 0
        self.num_removed = 0

    def append(self, item):
        self.lst.append(item)
        self.num_added += 1

    def remove(self, item):
        self.lst.remove(item)
        self.num_removed += 1

    def __str__(self):
        return str(self.lst)
```

В этом примере класс-обертка ListWrapper принимает список lst в конструкторе и сохраняет его в self.lst. Он также добавляет два новых атрибута num_added и num_removed, которые будут использоваться для отслеживания количества добавленных и удаленных элементов. Методы append и remove переопределены для изменения списка lst и увеличения соответствующих счетчиков. Метод `__str__()` переопределен для вывода списка в качестве строки.

Теперь можно создать объект ListWrapper и использовать его для работы с обычным списком, в то время как он будет отслеживать количество изменений списка:

```python
>>> lst = [1, 2, 3]
>>> wrapper = ListWrapper(lst)
>>> wrapper.append(4)
>>> wrapper.remove(2)
>>> print(wrapper)
[1, 3, 4]
>>> print(wrapper.num_added)
1
>>> print(wrapper.num_removed)
1
```

## Что такое класс-декоратор? Как создать класс-декоратор в Python?

**`Класс-декоратор`** - это класс, который принимает другой класс в качестве аргумента и возвращает измененную версию этого класса. Он используется для динамического изменения поведения класса, без изменения его исходного кода.

Для создания класс-декоратора в Python нужно определить новый класс, который будет принимать класс в качестве аргумента и возвращать измененную версию класса.

Пример класс-декоратора:

```python
class Decorator:
    def __init__(self, cls):
        self.cls = cls

    def __call__(self, *args, **kwargs):
        obj = self.cls(*args, **kwargs)
        obj.__class__ = self.new_cls()
        return obj

    def new_cls(self):
        class NewClass(self.cls):
            def new_method(self):
                print("New method added by decorator")

        return NewClass
```

В этом примере класс-декоратор Decorator принимает класс в своем конструкторе и сохраняет его в атрибуте cls. Метод call используется для создания нового объекта класса cls и замены его класса на новый класс, который возвращается методом new_cls. Метод new_cls создает новый класс на основе класса cls, добавляет новый метод new_method и возвращает новый класс.

Чтобы использовать класс-декоратор, нужно применить его к классу следующим образом:

```python
@Decorator
class MyClass:
    def my_method(self):
        print("My method")
```

В этом примере класс-декоратор Decorator применяется к классу MyClass с помощью декоратора @Decorator. Когда создается объект MyClass, он будет изменен с помощью метода new_cls, который добавляет новый метод new_method. Теперь можно создать объект MyClass и вызвать новый метод new_method:

```python
my_obj = MyClass()
my_obj.new_method()  # prints "New method added by decorator"
```

## Что такое атрибуты класса? Как создать атрибуты класса в Python?

**`Aтрибуты класса`** (или **`Свойства класса`**) - это переменные, объявленные и доступные внутри класса, но не зависят от конкретных экземпляров этого класса. Они хранятся в пространстве имен класса и доступны как для самого класса, так и для всех его экземпляров.

Для создания свойств класса в Python необходимо определить их внутри класса, как обычные переменные, но вне методов класса. Например:

```python
class MyClass:
    class_variable = 0

    def __init__(self, instance_variable):
        self.instance_variable = instance_variable
```

Здесь мы создали свойство class_variable, которое является общим для всех экземпляров класса MyClass, и свойство instance_variable, которое при каждом создании экземпляра будет уникальным для этого экземпляра.

Для доступа к свойству класса можно использовать имя класса:

```python
print(MyClass.class_variable)  # 0
```

Также свойство класса доступно для всех экземпляров класса:

```python
my_obj1 = MyClass('A')
my_obj2 = MyClass('B')

print(my_obj1.class_variable)  # 0
print(my_obj2.class_variable)  # 0
```

Для изменения значения свойства класса также можно использовать имя класса:

```python
MyClass.class_variable = 1
print(MyClass.class_variable)  # 1
```

Здесь мы изменили значение свойства class_variable у класса MyClass. Это изменение также отразится на свойствах класса всех его экземпляров:

```python
print(my_obj1.class_variable)  # 1
print(my_obj2.class_variable)  # 1
```

## Что такое примеси классов? Как создать примеси классов в Python?

**`Примеси классов`** (или **`миксины`**) в Python - это способ добавления функциональности к классу, не изменяя его исходного определения или наследуя другой класс. В основном, примеси классов используются для повторного использования кода и создания более гибких классов.

Чтобы создать примесь класса, необходимо определить класс с нужными методами и свойствами, а затем использовать этот класс в качестве базового класса для нужных классов. Также можно использовать декораторы (@) для добавления примеси к классу во время его определения.

Вот пример создания примеси класса для добавления логирования к другому классу:

```python
class LoggingMixin:
    def log(self, message):
        print(f"[{type(self).__name__}] {message}")
```

Здесь мы создали класс LoggingMixin, который содержит метод log для регистрации сообщений с помощью префикса класса. Далее, мы используем этот класс в качестве базового класса для нашего основного класса:

```python
class MyClass(LoggingMixin):
    def __init__(self, value):
        self.value = value

    def do_something(self):
        self.log(f"Doing something with {self.value}")
        # код метода
```

Здесь мы создали класс MyClass, который наследуется от LoggingMixin и использует его метод log() для регистрации сообщений. Теперь при создании экземпляра MyClass, мы можем использовать как его собственные методы, так и методы примеси LoggingMixin.
