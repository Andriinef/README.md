# OOP

## Какие принципы ООП поддерживает Python?

Принципы объектно-ориентированного программирования (ООП) в Python включают:

1. **Инкапсуляция** (Encapsulation): Это принцип, согласно которому класс должен скрывать внутренние детали реализации от других объектов. Это достигается путем использования атрибутов и методов класса, которые могут быть доступны только изнутри класса.

2. **Наследование** (Inheritance): Это принцип, согласно которому класс может наследовать свойства и методы другого класса. Класс, который наследует свойства и методы, называется подклассом, а класс, который передает свойства и методы, называется суперклассом.

3. **Полиморфизм** (Polymorphism): Это принцип, согласно которому различные объекты могут иметь одинаковые методы, но эти методы будут работать по-разному в зависимости от объекта, который их вызывает.

4. **Абстракция** (Abstraction): Это принцип, согласно которому класс должен скрывать детали реализации от других объектов и предоставлять только необходимые интерфейсы для работы с объектом. Абстракция достигается путем определения абстрактных классов и интерфейсов.

5. **Композиция** (Composition): Это принцип, согласно которому объект может быть создан из других объектов, которые представляют его составные части. Композиция позволяет создавать объекты с более сложным поведением и функциональностью.

6. **SOLID**: Это совокупность принципов, которые применяются в ООП и позволяют создавать гибкие, расширяемые и легко поддерживаемые программы. SOLID состоит из следующих принципов: Single Responsibility Principle, Open/Closed Principle, Liskov Substitution Principle, Interface Segregation Principle и Dependency Inversion Principle.

## Что такое наследование в Python?

**Наследование** - это один из ключевых механизмов объектно-ориентированного программирования, который позволяет создавать новые классы на основе уже существующих классов.

В Python наследование реализуется путем создания нового класса, который наследует атрибуты и методы существующего класса, называемого "родительским" или "супер" классом. Новый класс, который наследует свойства родительского класса, называется "подклассом" или "наследником".

Для того, чтобы создать подкласс, необходимо указать родительский класс в качестве аргумента при объявлении нового класса. В подклассе можно использовать все атрибуты и методы родительского класса, а также определять свои собственные атрибуты и методы.

Пример создания подкласса, наследующего свойства родительского класса:

```python
class Animal:
    def __init__(self, name):
        self.name = name

    def speak(self):
        raise NotImplementedError("Subclass must implement abstract method")

class Dog(Animal):
    def speak(self):
        return "Woof"
```

В этом примере класс Dog является подклассом класса Animal. Он наследует атрибут name и метод speak от родительского класса, но также определяет свой собственный метод speak, который переопределяет метод speak родительского класса.

## MRO ()

MRO означает порядок разрешения методов, то есть порядок, в котором Python ищет методы для выполнения в иерархии классов. MRO определяется алгоритмом линеаризации C3, который создает уникальный и непротиворечивый порядок классов с множественным наследованием.

В Python вы можете просмотреть MRO класса, используя метод mro(). Например, рассмотрим следующую иерархию классов:

```python
class A:
    pass

class B(A):
    pass

class C(A):
    pass

class D(B, C):
    pass
```

Чтобы просмотреть MRO класса D, вы можете вызвать для него метод mro():

```python
>>> D.mro()
[<class '__main__.D'>, <class '__main__.B'>, <class '__main__.C'>, <class '__main__.A'>, <class 'object'>]
```

MRO показывает, что когда вы вызываете метод для экземпляра D, Python сначала ищет метод в D, затем в B, затем в C, затем в A и, наконец, в объекте. Такой порядок гарантирует, что методы выполняются согласованным и предсказуемым образом в сценариях множественного наследования.

## Что такое полиморфизм в Python

**Полиморфизм** - это свойство объектно-ориентированного программирования, которое позволяет объектам разных классов иметь одинаковые методы и свойства, но реализованные каждым классом по-разному. В Python полиморфизм реализуется за счет использования методов, которые можно переопределить в наследуемых классах, а также за счет использования механизма динамической типизации.

В Python полиморфизм может быть достигнут благодаря концепции "duck typing" - "если выглядит как утка, плавает как утка и крякает как утка, то это, вероятно, и есть утка". То есть, в Python объекты не проверяются на соответствие определенному типу данных, вместо этого методы и свойства вызываются на объектах, и если они существуют и могут быть вызваны, то это считается достаточным.

Концепция полиморфизма в Python может быть применена в различных сферах программирования. Например, рассмотрим пример полиморфизма на примере классов "Figure", "Rectangle" и "Круг":

```python
from dataclasses import dataclass


@dataclass
class Figure:
    color: str

    def square(self, *args):
        pass


@dataclass
class Rectangle(Figure):
    color: str
    length: int
    width: int

    def square(self):
        return self.length * self.width


@dataclass
class Circle(Figure):
    color: str
    circle: int

    def square(self):
        return 3.14 * self.circle ** 2


figures = [Rectangle("red", 5, 3), Circle("blue", 4)]


for figure in figures:
    print(f"Square {type(figure).__name__}: {figure.square()}")

```

В этом примере классы "Rectangle" и "Круг" являются наследниками класса "Figure" и переопределяют его метод "square()". Создаем список объектов обоих классов и проходимся по ним циклом, вызывая метод "square()" для каждого объекта.

Результат выполнения программы будет следующим:

```code
square Rectangle: 15
square Circle: 50.24
```

В данном примере мы используем полиморфизм для того, чтобы вызывать один и тот же метод "square()" для объектов разных классов, но при этом получать разный результат в зависимости от типа объекта. Это позволяет использовать один и тот же код для работы с различными типами данных и объектами, делая программу более гибкой и удобной для разработки.

## Что такое абстракции в Python

Пример **абстракции** в объектно-ориентированном программировании с использованием Python:

```python
from abc import ABC, abstractmethod

class Shape(ABC):
    @abstractmethod
    def area(self):
        pass

class Rectangle(Shape):
    def __init__(self, width, height):
        self.width = width
        self.height = height

    def area(self):
        return self.width * self.height

class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius

    def area(self):
        return 3.14 * self.radius * self.radius

# Usage
rectangle = Rectangle(10, 5)
print(rectangle.area())

circle = Circle(5)
print(circle.area())
```

В этом примере у нас есть абстрактный класс Shape, который определяет область абстрактного метода. Этот метод не реализован в абстрактном классе, вместо этого он оставлен для реализации в конкретных классах. Это обеспечивает соблюдение концепции абстракции, поскольку абстрактный класс не связан с деталями реализации, а только с интерфейсом.

Затем у нас есть два конкретных класса, Rectangle и Circle, которые наследуются от класса Shape и реализуют свои собственные версии метода площади. Эти классы предоставляют свои собственные уникальные реализации области, но они оба используют одно и то же имя функции, что делает их взаимозаменяемыми.

Наконец, мы можем создать экземпляры Rectangle и Circle и вызвать для них метод области. Поскольку оба класса реализуют метод области, мы можем рассматривать их как экземпляры Shape и вызывать для них область взаимозаменяемо. Это сила абстракции, поскольку она позволяет нам писать гибкий код, который может работать с разными реализациями одного и того же интерфейса.

## Что такое инсапсуляция в Python

**Инкапсуляция** - это один из принципов объектно-ориентированного программирования, который позволяет скрыть реализацию объекта от других частей программы и предоставить интерфейс для работы с ним. В Python инкапсуляция достигается с помощью механизма атрибутов и методов доступа.

Основная идея инкапсуляции заключается в том, чтобы создать объекты, которые могут быть использованы только через определенный интерфейс. Этот интерфейс определяет, какие методы и атрибуты объекта можно использовать извне, а какие должны быть скрыты.

В Python инкапсуляция может быть реализована с помощью двух уровней доступа к атрибутам и методам объекта: публичный и приватный. Атрибуты и методы, которые должны быть скрыты от других частей программы, могут быть объявлены как приватные, то есть доступные только внутри класса. Для объявления приватных атрибутов и методов используется префикс двойного подчеркивания "__".

Например, в классе "Person" может быть объявлен приватный атрибут "name" следующим образом:

```python
class Person:
    def __init__(self, name):
        self.__name = name
```

Теперь атрибут "name" доступен только внутри класса "Person", и попытка обратиться к нему извне вызовет ошибку:

```python
p = Person("Alice")
print(p.__name) # вызовет ошибку AttributeError
```

Однако, чтобы позволить другим частям программы получать доступ к приватным атрибутам и методам, в Python существует механизм с помощью которого можно создать публичный метод для доступа к приватным атрибутам. Для этого используется префикс одинарного подчеркивания "_".

Например, в классе "Person" может быть объявлен публичный метод "get_name", который возвращает значение приватного атрибута "name":

```python
class Person:
    def __init__(self, name):
        self.__name = name

    def get_name(self):
        return self.__name
```

Теперь можно получить имя объекта "Person" с помощью публичного метода "get_name":

```python
p = Person("Alice")
print(p.get_name()) # выведет "Alice"
```

Таким образом, в Python инкапсуляция позволяет скрыть реализацию объекта от других частей программы и предоставить интерфейс для работы с ним, что повышает уровень абстракции

## Что является примером динамического связывания?

переопределение метода

## В каком случае будет уместно использование статического атрибута?

погодные условия для каждого дома в небольшом районе
